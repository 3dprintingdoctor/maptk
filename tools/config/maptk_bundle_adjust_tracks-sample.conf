
# the pixel aspect ratio of the base camera model
base_camera:aspect_ratio = 1.0

# focal length of the base camera model
base_camera:focal_length = 12600

# The principal point of the base camera model "x y".
# It is usually safe to assume this is the center of the image.
base_camera:principal_point = 360 240

# The skew factor of the base camera model.
# This is almost always zero in any real camera.
base_camera:skew = 0.0

# Dogleg strategy to use.
# Must be one of the following options:
#   - TRADITIONAL_DOGLEG
#   - SUBSPACE_DOGLEG
bundle_adjuster:ceres:dogleg_type = TRADITIONAL_DOGLEG

# Solver terminates if relative cost change is below this tolerance
bundle_adjuster:ceres:function_tolerance = 9.9999999999999995e-07

# Solver terminates if the maximum gradient is below this tolerance
bundle_adjuster:ceres:gradient_tolerance = 1e-10

# Lens distortion model to use.
# Must be one of the following options:
#   - NO_DISTORTION
#   - POLYNOMIAL_RADIAL_DISTORTION
#   - POLYNOMIAL_RADIAL_TANGENTIAL_DISTORTION
#   - RATIONAL_RADIAL_TANGENTIAL_DISTORTION
bundle_adjuster:ceres:lens_distortion_type = NO_DISTORTION

# Linear solver to use.
# Must be one of the following options:
#   - DENSE_NORMAL_CHOLESKY
#   - DENSE_QR
#   - SPARSE_NORMAL_CHOLESKY
#   - DENSE_SCHUR
#   - SPARSE_SCHUR
#   - ITERATIVE_SCHUR
#   - CGNR
bundle_adjuster:ceres:linear_solver_type = SPARSE_SCHUR

# Robust loss function scale factor.
bundle_adjuster:ceres:loss_function_scale = 1

# Robust loss function type to use.
# Must be one of the following options:
#   - TRIVIAL_LOSS
#   - HUBER_LOSS
#   - SOFT_L_ONE_LOSS
#   - CAUCHY_LOSS
#   - ARCTAN_LOSS
#   - TUKEY_LOSS
bundle_adjuster:ceres:loss_function_type = CAUCHY_LOSS

# Maximum number of iteration of allow
bundle_adjuster:ceres:max_num_iterations = 0

# Number of threads to use in the linear solver
bundle_adjuster:ceres:num_linear_solver_threads = 1

# Number of threads to use
bundle_adjuster:ceres:num_threads = 1

# Include aspect ratio parameters in bundle adjustment.
bundle_adjuster:ceres:optimize_aspect_ratio = false

# Include radial lens distortion parameter k1 in bundle adjustment.
bundle_adjuster:ceres:optimize_dist_k1 = true

# Include radial lens distortion parameter k2 in bundle adjustment.
bundle_adjuster:ceres:optimize_dist_k2 = false

# Include radial lens distortion parameter k3 in bundle adjustment.
bundle_adjuster:ceres:optimize_dist_k3 = false

# Include radial lens distortion parameters k4, k5, and k6 in bundle adjustment.
bundle_adjuster:ceres:optimize_dist_k4_k5_k6 = false

# Include tangential lens distortion parameters p1 and p2 in bundle adjustment.
bundle_adjuster:ceres:optimize_dist_p1_p2 = false

# Include focal length parameters in bundle adjustment.
bundle_adjuster:ceres:optimize_focal_length = true

# Include principal point parameters in bundle adjustment.
bundle_adjuster:ceres:optimize_principal_point = false

# Include skew parameters in bundle adjustment.
bundle_adjuster:ceres:optimize_skew = false

# Solver terminates if the relative change in parameters is below this tolerance
bundle_adjuster:ceres:parameter_tolerance = 1e-08

# Preconditioner to use.
# Must be one of the following options:
#   - IDENTITY
#   - JACOBI
#   - SCHUR_JACOBI
#   - CLUSTER_JACOBI
#   - CLUSTER_TRIDIAGONAL
bundle_adjuster:ceres:preconditioner_type = SCHUR_JACOBI

# Trust region step compution algorithm used by Ceres.
# Must be one of the following options:
#   - LEVENBERG_MARQUARDT
#   - DOGLEG
bundle_adjuster:ceres:trust_region_strategy_type = LEVENBERG_MARQUARDT

# If true, write status messages to the terminal showing optimization progress
# at each iteration
bundle_adjuster:ceres:verbose = true

# Algorithm to use for 'bundle_adjuster', which is of type 'bundle_adjust'.
# Must be one of the following options:
# 	- ceres
# 	- hierarchical
# 	- vxl
bundle_adjuster:type = ceres

# Sub-sample the cameras for by this rate.
# Set to 1 to use all cameras, 2 to use every other camera, etc.
camera_sample_rate = 1

# Path to write a file containing filtered feature tracks
filtered_track_file = filtered_tracks.txt

# Algorithm to use for 'geo_mapper', which is of type 'geo_map'.
# Must be one of the following options:
# 	- proj
geo_mapper:type = proj

# Path to the input image list file used to generated the input tracks.
image_list_file = frames.txt

# When loading a subset of cameras, should we optimize only the loaded cameras
# or also initialize and optimize the unspecified cameras
initialize_unloaded_cameras = true

# the pixel aspect ratio of the base camera model
initializer:core:base_camera:aspect_ratio = 1

# focal length of the base camera model
initializer:core:base_camera:focal_length = 12600

# The principal point of the base camera model "x y".
# It is usually safe to assume this is the center of the image.
initializer:core:base_camera:principal_point = 360 240

# The skew factor of the base camera model.
# This is almost always zero in any real camera.
initializer:core:base_camera:skew = 0

# Dogleg strategy to use.
# Must be one of the following options:
#   - TRADITIONAL_DOGLEG
#   - SUBSPACE_DOGLEG
initializer:core:bundle_adjuster:ceres:dogleg_type = TRADITIONAL_DOGLEG

# Solver terminates if relative cost change is below this tolerance
initializer:core:bundle_adjuster:ceres:function_tolerance = 9.9999999999999995e-07

# Solver terminates if the maximum gradient is below this tolerance
initializer:core:bundle_adjuster:ceres:gradient_tolerance = 1e-10

# Lens distortion model to use.
# Must be one of the following options:
#   - NO_DISTORTION
#   - POLYNOMIAL_RADIAL_DISTORTION
#   - POLYNOMIAL_RADIAL_TANGENTIAL_DISTORTION
#   - RATIONAL_RADIAL_TANGENTIAL_DISTORTION
initializer:core:bundle_adjuster:ceres:lens_distortion_type = NO_DISTORTION

# Linear solver to use.
# Must be one of the following options:
#   - DENSE_NORMAL_CHOLESKY
#   - DENSE_QR
#   - SPARSE_NORMAL_CHOLESKY
#   - DENSE_SCHUR
#   - SPARSE_SCHUR
#   - ITERATIVE_SCHUR
#   - CGNR
initializer:core:bundle_adjuster:ceres:linear_solver_type = SPARSE_SCHUR

# Robust loss function scale factor.
initializer:core:bundle_adjuster:ceres:loss_function_scale = 1

# Robust loss function type to use.
# Must be one of the following options:
#   - TRIVIAL_LOSS
#   - HUBER_LOSS
#   - SOFT_L_ONE_LOSS
#   - CAUCHY_LOSS
#   - ARCTAN_LOSS
#   - TUKEY_LOSS
initializer:core:bundle_adjuster:ceres:loss_function_type = CAUCHY_LOSS

# Maximum number of iteration of allow
initializer:core:bundle_adjuster:ceres:max_num_iterations = 200

# Number of threads to use in the linear solver
initializer:core:bundle_adjuster:ceres:num_linear_solver_threads = 1

# Number of threads to use
initializer:core:bundle_adjuster:ceres:num_threads = 1

# Include aspect ratio parameters in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_aspect_ratio = false

# Include radial lens distortion parameter k1 in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_dist_k1 = true

# Include radial lens distortion parameter k2 in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_dist_k2 = false

# Include radial lens distortion parameter k3 in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_dist_k3 = false

# Include radial lens distortion parameters k4, k5, and k6 in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_dist_k4_k5_k6 = false

# Include tangential lens distortion parameters p1 and p2 in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_dist_p1_p2 = false

# Include focal length parameters in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_focal_length = false

# Include principal point parameters in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_principal_point = false

# Include skew parameters in bundle adjustment.
initializer:core:bundle_adjuster:ceres:optimize_skew = false

# Solver terminates if the relative change in parameters is below this tolerance
initializer:core:bundle_adjuster:ceres:parameter_tolerance = 1e-08

# Preconditioner to use.
# Must be one of the following options:
#   - IDENTITY
#   - JACOBI
#   - SCHUR_JACOBI
#   - CLUSTER_JACOBI
#   - CLUSTER_TRIDIAGONAL
initializer:core:bundle_adjuster:ceres:preconditioner_type = JACOBI

# Trust region step compution algorithm used by Ceres.
# Must be one of the following options:
#   - LEVENBERG_MARQUARDT
#   - DOGLEG
initializer:core:bundle_adjuster:ceres:trust_region_strategy_type = LEVENBERG_MARQUARDT

# If true, write status messages to the terminal showing optimization progress
# at each iteration
initializer:core:bundle_adjuster:ceres:verbose = true

# Algorithm to use for 'bundle_adjuster', which is of type 'bundle_adjust'.
# Must be one of the following options:
# 	- ceres
# 	- hierarchical
# 	- vxl
initializer:core:bundle_adjuster:type = ceres

# Algorithm to use for 'camera_optimizer', which is of type 'optimize_cameras'.
# Must be one of the following options:
# 	- vxl
initializer:core:camera_optimizer:type = vxl

# Algorithm to use for 'essential_mat_estimator', which is of type
# 'estimate_essential_matrix'.
# Must be one of the following options:
# 	- vxl
initializer:core:essential_mat_estimator:type = vxl

# The number of samples to use in RANSAC
initializer:core:essential_mat_estimator:vxl:num_ransac_samples = 512

# If true, write status messages to the terminal showing debugging information
initializer:core:essential_mat_estimator:vxl:verbose = false

# If true, and a camera optimizer is specified, initialize the camera using the
# closest exiting camera and optimize
initializer:core:init_from_last = true

# Use the homogeneous method for triangulating points. The homogeneous method
# can triangulate points at or near infinity and discard them.
initializer:core:lm_triangulator:core:homogeneous = false

# Algorithm to use for 'lm_triangulator', which is of type
# 'triangulate_landmarks'.
# Must be one of the following options:
# 	- core
# 	- vxl
initializer:core:lm_triangulator:type = core

# If true, re-triangulate all landmarks observed by a newly initialized camera.
# Otherwise, only triangulate or re-triangulate landmarks that are marked for
# initialization.
initializer:core:retriangulate_all = false

# If true, write status messages to the terminal showing debugging information
initializer:core:verbose = false

# Algorithm to use for 'initializer', which is of type
# 'initialize_cameras_landmarks'.
# Must be one of the following options:
# 	- core
initializer:type = core

# A directory containing input KRTD camera files, or a text file containing a
# newline-separated list of KRTD files.
#
# This is optional, leave blank to ignore.
#
# This is mutually exclusive with input_pos_files option for system
# initialization, and shadowed by the input_reference_points_file when using an
# st_estimator.
input_krtd_files =

# A directory containing the input POS files, or a text filecontaining a
# newline-separated list of POS files.
#
# This is optional, leave blank to ignore.
#
# This is mutually exclusive with the input_krtd_files option for system
# initialization, and shadowed by the input_reference_points option when using
# an st_estimator.
input_pos_files =

# File containing reference points to use for reprojection of results into the
# geographic coordinate system.
#
# This option is NOT mutually exclusive with input_*_files options when using an
# st_estimator. When both this and another input files option are specified, use
# of the reference file is given priority over the input cameras.
#
# Reference points file format (lm=landmark, tNsM=track N state M):
# 	lm1.x lm1.y lm1.z t1s1.frame t1s1.x t1s1.y t1s2.frame t1s2.x t1s2.y ...
# 	lm2.x lm2.y lm2.z t2s1.frame t2s1.x t2s1.y t2s2.frame t2s2.x t2s2.y ...
# 	...
#
# At least 3 landmarks must be given, with at least 2 track states recorded for
# each landmark, for transformation estimation to converge, however more of each
# is recommended.
#
# Landmark z position, or altitude, should be provided in meters.
input_reference_points_file =

# Path an input file containing feature tracks
input_track_file = tracks.txt

# A quaternion used to offset rotation data from POS files when updating
# cameras. This option is only relevent if a value is give to the
# input_pos_files option.
ins:rotation_offset = 0 0 0 1

# Filter the input tracks keeping those covering at least this many frames.
min_track_length = 20

# Apply a Necker reversal to the initial cameras and landmarks
necker_reverse_input = false

# A directory in which to write the output KRTD files.
output_krtd_dir = ba_output/krtd

# Path to the output PLY file in which to write resulting 3D landmark points
output_ply_file = ba_output/landmarks.ply

# A directory in which to write the output POS files.
output_pos_dir = ba_output/pos

# Algorithm to use for 'st_estimator', which is of type
# 'estimate_similarity_transform'.
# Must be one of the following options:
# 	- vxl
st_estimator:type = vxl

# Use the homogeneous method for triangulating points. The homogeneous method
# can triangulate points at or near infinity and discard them.
triangulator:core:homogeneous = false

# Algorithm to use for 'triangulator', which is of type 'triangulate_landmarks'.
# Must be one of the following options:
# 	- core
# 	- vxl
triangulator:type = core
